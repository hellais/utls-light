diff --git a/tls/conn.go b/tls/conn.go
index c04bd48d6a..a81f08a67c 100644
--- a/tls/conn.go
+++ b/tls/conn.go
@@ -1147,6 +1147,12 @@ func (c *Conn) unmarshalHandshakeMessage(data []byte, transcript transcriptHash)
 		m = new(endOfEarlyDataMsg)
 	case typeKeyUpdate:
 		m = new(keyUpdateMsg)
+
+	// <UTLS-LIGHT>
+	case typeCompressedCertificate:
+		m = new(compressedCertificateMsg)
+	// </UTLS-LIGHT>
+
 	default:
 		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
 	}
diff --git a/tls/handshake_messages.go b/tls/handshake_messages.go
index a86055a060..29ac75035d 100644
--- a/tls/handshake_messages.go
+++ b/tls/handshake_messages.go
@@ -95,6 +95,11 @@ type clientHelloMsg struct {
 	pskIdentities                    []pskIdentity
 	pskBinders                       [][]byte
 	quicTransportParameters          []byte
+
+	// <UTLS-LIGHT>
+	// Used to signal the marshal function if we should disable greasing the keyshare field
+	noGreaseKeyshare bool
+	// </UTLS-LIGHT>
 }
 
 func (m *clientHelloMsg) marshal() ([]byte, error) {
diff --git a/tls/handshake_server_tls13.go b/tls/handshake_server_tls13.go
index 07b1a3851e..c6c175fbf6 100644
--- a/tls/handshake_server_tls13.go
+++ b/tls/handshake_server_tls13.go
@@ -221,6 +221,10 @@ GroupSelection:
 		return err
 	}
 	hs.hello.serverShare = keyShare{group: selectedGroup, data: key.PublicKey().Bytes()}
+	// <UTLS-LIGHT>
+	// We use this to signal the marshaller that we don't want any GREASE in our key_shares
+	hs.hello.noGreaseKeyshare = true
+	// </UTLS-LIGHT>
 	peerKey, err := key.Curve().NewPublicKey(clientKeyShare.data)
 	if err != nil {
 		c.sendAlert(alertIllegalParameter)
diff --git a/utls/conn.go b/utls/conn.go
index 9d3316b05e..d202e4751c 100644
--- a/utls/conn.go
+++ b/utls/conn.go
@@ -588,12 +588,14 @@ func (c *Conn) readChangeCipherSpec() error {
 
 // readRecordOrCCS reads one or more TLS records from the connection and
 // updates the record layer state. Some invariants:
-//   * c.in must be locked
-//   * c.input must be empty
+//   - c.in must be locked
+//   - c.input must be empty
+//
 // During the handshake one and only one of the following will happen:
 //   - c.hand grows
 //   - c.in.changeCipherSpec is called
 //   - an error is returned
+//
 // After the handshake one and only one of the following will happen:
 //   - c.hand grows
 //   - c.input is set
