diff --git a/tls/conn.go b/tls/conn.go
index c04bd48d6a..a81f08a67c 100644
--- a/tls/conn.go
+++ b/tls/conn.go
@@ -1147,6 +1147,12 @@ func (c *Conn) unmarshalHandshakeMessage(data []byte, transcript transcriptHash)
 		m = new(endOfEarlyDataMsg)
 	case typeKeyUpdate:
 		m = new(keyUpdateMsg)
+
+	// <UTLS-LIGHT>
+	case typeCompressedCertificate:
+		m = new(compressedCertificateMsg)
+	// </UTLS-LIGHT>
+
 	default:
 		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
 	}
diff --git a/tls/handshake_messages.go b/tls/handshake_messages.go
index a86055a060..29ac75035d 100644
--- a/tls/handshake_messages.go
+++ b/tls/handshake_messages.go
@@ -95,6 +95,11 @@ type clientHelloMsg struct {
 	pskIdentities                    []pskIdentity
 	pskBinders                       [][]byte
 	quicTransportParameters          []byte
+
+	// <UTLS-LIGHT>
+	// Used to signal the marshal function if we should disable greasing the keyshare field
+	noGreaseKeyshare bool
+	// </UTLS-LIGHT>
 }
 
 func (m *clientHelloMsg) marshal() ([]byte, error) {
diff --git a/tls/handshake_server_tls13.go b/tls/handshake_server_tls13.go
index 07b1a3851e..c6c175fbf6 100644
--- a/tls/handshake_server_tls13.go
+++ b/tls/handshake_server_tls13.go
@@ -221,6 +221,10 @@ GroupSelection:
 		return err
 	}
 	hs.hello.serverShare = keyShare{group: selectedGroup, data: key.PublicKey().Bytes()}
+	// <UTLS-LIGHT>
+	// We use this to signal the marshaller that we don't want any GREASE in our key_shares
+	hs.hello.noGreaseKeyshare = true
+	// </UTLS-LIGHT>
 	peerKey, err := key.Curve().NewPublicKey(clientKeyShare.data)
 	if err != nil {
 		c.sendAlert(alertIllegalParameter)
